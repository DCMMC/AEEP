/*
 *  This file is auto generated by oeedger8r. DO NOT EDIT.
 */
#include "enclave_t.h"

#include <openenclave/edger8r/enclave.h>

OE_EXTERNC_BEGIN

/**** Trusted function IDs ****/
enum
{
    enclave_fcn_id_enclave_run = 0,
    enclave_fcn_id_enclave_deploy = 1,
    enclave_fcn_id_trusted_call_id_max = OE_ENUM_MAX
};

/**** ECALL marshalling structs. ****/
typedef struct _enclave_run_args_t
{
    oe_result_t _result;
    exec_result_struct* result;
    gs_struct* _gs;
    tx_struct* _tx;
    unsigned char* _caller;
    unsigned char* _callee;
    uint8_t* _input;
    size_t _input_size;
    unsigned char* _call_value;
} enclave_run_args_t;

typedef struct _enclave_deploy_args_t
{
    oe_result_t _result;
    gs_struct* _gs;
    tx_struct* _tx;
    unsigned char* _caller;
    uint8_t* _constructor;
    size_t _constructor_size;
    unsigned char* contract_address;
} enclave_deploy_args_t;

/**** ECALL functions. ****/

static void ecall_enclave_run(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    enclave_run_args_t* pargs_in = (enclave_run_args_t*)input_buffer;
    enclave_run_args_t* pargs_out = (enclave_run_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    /* oe_is_within_enclave explicitly checks if buffers are null or not. */
    if (!oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->result)
        OE_SET_IN_OUT_POINTER(result, sizeof(exec_result_struct), exec_result_struct*);
    if (pargs_in->_gs)
        OE_SET_IN_OUT_POINTER(_gs, sizeof(gs_struct), gs_struct*);
    if (pargs_in->_tx)
        OE_SET_IN_OUT_POINTER(_tx, sizeof(tx_struct), tx_struct*);
    if (pargs_in->_caller)
        OE_SET_IN_OUT_POINTER(_caller, 100, unsigned char*);
    if (pargs_in->_callee)
        OE_SET_IN_OUT_POINTER(_callee, 100, unsigned char*);
    if (pargs_in->_input)
        OE_SET_IN_OUT_POINTER(_input, pargs_in->_input_size, uint8_t*);
    if (pargs_in->_call_value)
        OE_SET_IN_OUT_POINTER(_call_value, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->result)
        OE_COPY_AND_SET_IN_OUT_POINTER(result, sizeof(exec_result_struct), exec_result_struct*);
    if (pargs_in->_gs)
        OE_COPY_AND_SET_IN_OUT_POINTER(_gs, sizeof(gs_struct), gs_struct*);
    if (pargs_in->_tx)
        OE_COPY_AND_SET_IN_OUT_POINTER(_tx, sizeof(tx_struct), tx_struct*);
    if (pargs_in->_caller)
        OE_COPY_AND_SET_IN_OUT_POINTER(_caller, 100, unsigned char*);
    if (pargs_in->_callee)
        OE_COPY_AND_SET_IN_OUT_POINTER(_callee, 100, unsigned char*);
    if (pargs_in->_input)
        OE_COPY_AND_SET_IN_OUT_POINTER(_input, pargs_in->_input_size, uint8_t*);
    if (pargs_in->_call_value)
        OE_COPY_AND_SET_IN_OUT_POINTER(_call_value, 100, unsigned char*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    enclave_run(
        pargs_in->result,
        pargs_in->_gs,
        pargs_in->_tx,
        pargs_in->_caller,
        pargs_in->_callee,
        pargs_in->_input,
        pargs_in->_input_size,
        pargs_in->_call_value);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (output_buffer_size >= sizeof(*pargs_out) &&
        oe_is_within_enclave(pargs_out, output_buffer_size))
        pargs_out->_result = _result;
}

static void ecall_enclave_deploy(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters. */
    enclave_deploy_args_t* pargs_in = (enclave_deploy_args_t*)input_buffer;
    enclave_deploy_args_t* pargs_out = (enclave_deploy_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave. */
    /* oe_is_within_enclave explicitly checks if buffers are null or not. */
    if (!oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers. */
    if (pargs_in->_gs)
        OE_SET_IN_OUT_POINTER(_gs, sizeof(gs_struct), gs_struct*);
    if (pargs_in->_tx)
        OE_SET_IN_OUT_POINTER(_tx, sizeof(tx_struct), tx_struct*);
    if (pargs_in->_caller)
        OE_SET_IN_OUT_POINTER(_caller, 100, unsigned char*);
    if (pargs_in->_constructor)
        OE_SET_IN_OUT_POINTER(_constructor, pargs_in->_constructor_size, uint8_t*);
    if (pargs_in->contract_address)
        OE_SET_IN_OUT_POINTER(contract_address, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->_gs)
        OE_COPY_AND_SET_IN_OUT_POINTER(_gs, sizeof(gs_struct), gs_struct*);
    if (pargs_in->_tx)
        OE_COPY_AND_SET_IN_OUT_POINTER(_tx, sizeof(tx_struct), tx_struct*);
    if (pargs_in->_caller)
        OE_COPY_AND_SET_IN_OUT_POINTER(_caller, 100, unsigned char*);
    if (pargs_in->_constructor)
        OE_COPY_AND_SET_IN_OUT_POINTER(_constructor, pargs_in->_constructor_size, uint8_t*);
    if (pargs_in->contract_address)
        OE_COPY_AND_SET_IN_OUT_POINTER(contract_address, 100, unsigned char*);

    /* Check that in/in-out strings are null terminated. */
    /* There were no in nor in-out string parameters. */

    /* lfence after checks. */
    oe_lfence();

    /* Call user function. */
    enclave_deploy(
        pargs_in->_gs,
        pargs_in->_tx,
        pargs_in->_caller,
        pargs_in->_constructor,
        pargs_in->_constructor_size,
        pargs_in->contract_address);

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (output_buffer_size >= sizeof(*pargs_out) &&
        oe_is_within_enclave(pargs_out, output_buffer_size))
        pargs_out->_result = _result;
}

/**** ECALL function table. ****/

oe_ecall_func_t __oe_ecalls_table[] = {
    (oe_ecall_func_t) ecall_enclave_run,
    (oe_ecall_func_t) ecall_enclave_deploy
};

size_t __oe_ecalls_table_size = OE_COUNTOF(__oe_ecalls_table);

/**** Untrusted function IDs. ****/
enum
{
    enclave_fcn_id_push_ocall = 0,
    enclave_fcn_id_add_ocall = 1,
    enclave_fcn_id_mul_ocall = 2,
    enclave_fcn_id_sub_ocall = 3,
    enclave_fcn_id_div_ocall = 4,
    enclave_fcn_id_sdiv_ocall = 5,
    enclave_fcn_id_mod_ocall = 6,
    enclave_fcn_id_smod_ocall = 7,
    enclave_fcn_id_addmod_ocall = 8,
    enclave_fcn_id_mulmod_ocall = 9,
    enclave_fcn_id_exp_ocall = 10,
    enclave_fcn_id_signextend_ocall = 11,
    enclave_fcn_id_lt_ocall = 12,
    enclave_fcn_id_gt_ocall = 13,
    enclave_fcn_id_slt_ocall = 14,
    enclave_fcn_id_eq_ocall = 15,
    enclave_fcn_id_isZero_ocall = 16,
    enclave_fcn_id_and_ocall = 17,
    enclave_fcn_id_or_ocall = 18,
    enclave_fcn_id_xor_ocall = 19,
    enclave_fcn_id_not_ocall = 20,
    enclave_fcn_id_byte_ocall = 21,
    enclave_fcn_id_shl_ocall = 22,
    enclave_fcn_id_shr_ocall = 23,
    enclave_fcn_id_mstore8_ocall = 24,
    enclave_fcn_id_calldataload_ocall = 25,
    enclave_fcn_id_blockhash_ocall = 26,
    enclave_fcn_id_sha3_ocall = 27,
    enclave_fcn_id_generate_address_ocall = 28,
    enclave_fcn_id_to_big_endian_ocall = 29,
    enclave_fcn_id_from_big_endian_ocall = 30,
    enclave_fcn_id_oe_sgx_get_cpuid_table_ocall = 31,
    enclave_fcn_id_untrusted_call_max = OE_ENUM_MAX
};

/**** OCALL marshalling structs. ****/
typedef struct _push_ocall_args_t
{
    oe_result_t _result;
    uint64_t* pc;
    uint8_t bytes;
    uint8_t* code_arr;
    size_t code_size;
    unsigned char* res;
} push_ocall_args_t;

typedef struct _add_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} add_ocall_args_t;

typedef struct _mul_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} mul_ocall_args_t;

typedef struct _sub_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} sub_ocall_args_t;

typedef struct _div_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} div_ocall_args_t;

typedef struct _sdiv_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} sdiv_ocall_args_t;

typedef struct _mod_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} mod_ocall_args_t;

typedef struct _smod_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} smod_ocall_args_t;

typedef struct _addmod_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* m;
    unsigned char* res;
} addmod_ocall_args_t;

typedef struct _mulmod_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* m;
    unsigned char* res;
} mulmod_ocall_args_t;

typedef struct _exp_ocall_args_t
{
    oe_result_t _result;
    unsigned char* b;
    unsigned char* e;
    unsigned char* res;
} exp_ocall_args_t;

typedef struct _signextend_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} signextend_ocall_args_t;

typedef struct _lt_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} lt_ocall_args_t;

typedef struct _gt_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} gt_ocall_args_t;

typedef struct _slt_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} slt_ocall_args_t;

typedef struct _eq_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} eq_ocall_args_t;

typedef struct _isZero_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* res;
} isZero_ocall_args_t;

typedef struct _and_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} and_ocall_args_t;

typedef struct _or_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} or_ocall_args_t;

typedef struct _xor_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} xor_ocall_args_t;

typedef struct _not_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* res;
} not_ocall_args_t;

typedef struct _byte_ocall_args_t
{
    oe_result_t _result;
    unsigned char* idx;
    unsigned char* val;
    unsigned char* res;
} byte_ocall_args_t;

typedef struct _shl_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} shl_ocall_args_t;

typedef struct _shr_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} shr_ocall_args_t;

typedef struct _mstore8_ocall_args_t
{
    oe_result_t _result;
    uint8_t* b;
    unsigned char* n;
} mstore8_ocall_args_t;

typedef struct _calldataload_ocall_args_t
{
    oe_result_t _result;
    uint64_t offset;
    uint64_t sizeInput;
    uint8_t* input;
    size_t input_size;
    unsigned char* res;
} calldataload_ocall_args_t;

typedef struct _blockhash_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* res;
} blockhash_ocall_args_t;

typedef struct _sha3_ocall_args_t
{
    oe_result_t _result;
    uint8_t* h;
    unsigned char* res;
} sha3_ocall_args_t;

typedef struct _generate_address_ocall_args_t
{
    oe_result_t _result;
    unsigned char* sender;
    size_t nonce;
    unsigned char* newAddress;
} generate_address_ocall_args_t;

typedef struct _to_big_endian_ocall_args_t
{
    oe_result_t _result;
    unsigned char* v;
    uint8_t* out;
    size_t out_size;
} to_big_endian_ocall_args_t;

typedef struct _from_big_endian_ocall_args_t
{
    oe_result_t _result;
    uint8_t* begin;
    size_t size;
    size_t begin_size;
    unsigned char* res;
} from_big_endian_ocall_args_t;

typedef struct _oe_sgx_get_cpuid_table_ocall_args_t
{
    oe_result_t _result;
    oe_result_t _retval;
    void* cpuid_table_buffer;
    size_t cpuid_table_buffer_size;
} oe_sgx_get_cpuid_table_ocall_args_t;

/**** OCALL function wrappers. ****/

oe_result_t push_ocall(
    uint64_t* pc,
    uint8_t bytes,
    uint8_t* code_arr,
    size_t code_size,
    unsigned char* res)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    push_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.pc = (uint64_t*)pc;
    _args.bytes = bytes;
    _args.code_arr = (uint8_t*)code_arr;
    _args.code_size = code_size;
    _args.res = (unsigned char*)res;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(push_ocall_args_t));
    if (pc)
        OE_ADD_SIZE(_input_buffer_size, sizeof(uint64_t));
    if (code_arr)
        OE_ADD_SIZE(_input_buffer_size, _args.code_size);
    if (res)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(push_ocall_args_t));
    if (pc)
        OE_ADD_SIZE(_output_buffer_size, sizeof(uint64_t));
    if (code_arr)
        OE_ADD_SIZE(_output_buffer_size, _args.code_size);
    if (res)
        OE_ADD_SIZE(_output_buffer_size, 100);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (push_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (pc)
        OE_WRITE_IN_OUT_PARAM(pc, sizeof(uint64_t), uint64_t*);
    if (code_arr)
        OE_WRITE_IN_OUT_PARAM(code_arr, _args.code_size, uint8_t*);
    if (res)
        OE_WRITE_IN_OUT_PARAM(res, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_push_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (push_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(pc, (size_t)(sizeof(uint64_t)));
    OE_READ_IN_OUT_PARAM(code_arr, (size_t)(_args.code_size));
    OE_READ_IN_OUT_PARAM(res, (size_t)(100));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t add_ocall(
    unsigned char* x,
    unsigned char* y,
    unsigned char* res)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    add_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.x = (unsigned char*)x;
    _args.y = (unsigned char*)y;
    _args.res = (unsigned char*)res;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(add_ocall_args_t));
    if (x)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (y)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (res)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(add_ocall_args_t));
    if (res)
        OE_ADD_SIZE(_output_buffer_size, 100);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (add_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (x)
        OE_WRITE_IN_PARAM(x, 100, unsigned char*);
    if (y)
        OE_WRITE_IN_PARAM(y, 100, unsigned char*);
    if (res)
        OE_WRITE_IN_OUT_PARAM(res, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_add_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (add_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(res, (size_t)(100));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t mul_ocall(
    unsigned char* x,
    unsigned char* y,
    unsigned char* res)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    mul_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.x = (unsigned char*)x;
    _args.y = (unsigned char*)y;
    _args.res = (unsigned char*)res;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(mul_ocall_args_t));
    if (x)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (y)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (res)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(mul_ocall_args_t));
    if (res)
        OE_ADD_SIZE(_output_buffer_size, 100);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (mul_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (x)
        OE_WRITE_IN_PARAM(x, 100, unsigned char*);
    if (y)
        OE_WRITE_IN_PARAM(y, 100, unsigned char*);
    if (res)
        OE_WRITE_IN_OUT_PARAM(res, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_mul_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (mul_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(res, (size_t)(100));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t sub_ocall(
    unsigned char* x,
    unsigned char* y,
    unsigned char* res)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    sub_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.x = (unsigned char*)x;
    _args.y = (unsigned char*)y;
    _args.res = (unsigned char*)res;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(sub_ocall_args_t));
    if (x)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (y)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (res)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(sub_ocall_args_t));
    if (res)
        OE_ADD_SIZE(_output_buffer_size, 100);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (sub_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (x)
        OE_WRITE_IN_PARAM(x, 100, unsigned char*);
    if (y)
        OE_WRITE_IN_PARAM(y, 100, unsigned char*);
    if (res)
        OE_WRITE_IN_OUT_PARAM(res, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_sub_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (sub_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(res, (size_t)(100));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t div_ocall(
    unsigned char* x,
    unsigned char* y,
    unsigned char* res)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    div_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.x = (unsigned char*)x;
    _args.y = (unsigned char*)y;
    _args.res = (unsigned char*)res;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(div_ocall_args_t));
    if (x)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (y)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (res)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(div_ocall_args_t));
    if (res)
        OE_ADD_SIZE(_output_buffer_size, 100);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (div_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (x)
        OE_WRITE_IN_PARAM(x, 100, unsigned char*);
    if (y)
        OE_WRITE_IN_PARAM(y, 100, unsigned char*);
    if (res)
        OE_WRITE_IN_OUT_PARAM(res, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_div_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (div_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(res, (size_t)(100));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t sdiv_ocall(
    unsigned char* x,
    unsigned char* y,
    unsigned char* res)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    sdiv_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.x = (unsigned char*)x;
    _args.y = (unsigned char*)y;
    _args.res = (unsigned char*)res;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(sdiv_ocall_args_t));
    if (x)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (y)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (res)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(sdiv_ocall_args_t));
    if (res)
        OE_ADD_SIZE(_output_buffer_size, 100);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (sdiv_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (x)
        OE_WRITE_IN_PARAM(x, 100, unsigned char*);
    if (y)
        OE_WRITE_IN_PARAM(y, 100, unsigned char*);
    if (res)
        OE_WRITE_IN_OUT_PARAM(res, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_sdiv_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (sdiv_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(res, (size_t)(100));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t mod_ocall(
    unsigned char* x,
    unsigned char* y,
    unsigned char* res)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    mod_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.x = (unsigned char*)x;
    _args.y = (unsigned char*)y;
    _args.res = (unsigned char*)res;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(mod_ocall_args_t));
    if (x)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (y)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (res)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(mod_ocall_args_t));
    if (res)
        OE_ADD_SIZE(_output_buffer_size, 100);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (mod_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (x)
        OE_WRITE_IN_PARAM(x, 100, unsigned char*);
    if (y)
        OE_WRITE_IN_PARAM(y, 100, unsigned char*);
    if (res)
        OE_WRITE_IN_OUT_PARAM(res, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_mod_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (mod_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(res, (size_t)(100));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t smod_ocall(
    unsigned char* x,
    unsigned char* y,
    unsigned char* res)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    smod_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.x = (unsigned char*)x;
    _args.y = (unsigned char*)y;
    _args.res = (unsigned char*)res;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(smod_ocall_args_t));
    if (x)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (y)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (res)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(smod_ocall_args_t));
    if (res)
        OE_ADD_SIZE(_output_buffer_size, 100);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (smod_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (x)
        OE_WRITE_IN_PARAM(x, 100, unsigned char*);
    if (y)
        OE_WRITE_IN_PARAM(y, 100, unsigned char*);
    if (res)
        OE_WRITE_IN_OUT_PARAM(res, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_smod_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (smod_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(res, (size_t)(100));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t addmod_ocall(
    unsigned char* x,
    unsigned char* y,
    unsigned char* m,
    unsigned char* res)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    addmod_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.x = (unsigned char*)x;
    _args.y = (unsigned char*)y;
    _args.m = (unsigned char*)m;
    _args.res = (unsigned char*)res;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(addmod_ocall_args_t));
    if (x)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (y)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (m)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (res)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(addmod_ocall_args_t));
    if (res)
        OE_ADD_SIZE(_output_buffer_size, 100);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (addmod_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (x)
        OE_WRITE_IN_PARAM(x, 100, unsigned char*);
    if (y)
        OE_WRITE_IN_PARAM(y, 100, unsigned char*);
    if (m)
        OE_WRITE_IN_PARAM(m, 100, unsigned char*);
    if (res)
        OE_WRITE_IN_OUT_PARAM(res, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_addmod_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (addmod_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(res, (size_t)(100));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t mulmod_ocall(
    unsigned char* x,
    unsigned char* y,
    unsigned char* m,
    unsigned char* res)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    mulmod_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.x = (unsigned char*)x;
    _args.y = (unsigned char*)y;
    _args.m = (unsigned char*)m;
    _args.res = (unsigned char*)res;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(mulmod_ocall_args_t));
    if (x)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (y)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (m)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (res)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(mulmod_ocall_args_t));
    if (res)
        OE_ADD_SIZE(_output_buffer_size, 100);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (mulmod_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (x)
        OE_WRITE_IN_PARAM(x, 100, unsigned char*);
    if (y)
        OE_WRITE_IN_PARAM(y, 100, unsigned char*);
    if (m)
        OE_WRITE_IN_PARAM(m, 100, unsigned char*);
    if (res)
        OE_WRITE_IN_OUT_PARAM(res, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_mulmod_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (mulmod_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(res, (size_t)(100));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t exp_ocall(
    unsigned char* b,
    unsigned char* e,
    unsigned char* res)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    exp_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.b = (unsigned char*)b;
    _args.e = (unsigned char*)e;
    _args.res = (unsigned char*)res;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(exp_ocall_args_t));
    if (b)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (e)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (res)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(exp_ocall_args_t));
    if (res)
        OE_ADD_SIZE(_output_buffer_size, 100);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (exp_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (b)
        OE_WRITE_IN_PARAM(b, 100, unsigned char*);
    if (e)
        OE_WRITE_IN_PARAM(e, 100, unsigned char*);
    if (res)
        OE_WRITE_IN_OUT_PARAM(res, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_exp_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (exp_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(res, (size_t)(100));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t signextend_ocall(
    unsigned char* x,
    unsigned char* y,
    unsigned char* res)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    signextend_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.x = (unsigned char*)x;
    _args.y = (unsigned char*)y;
    _args.res = (unsigned char*)res;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(signextend_ocall_args_t));
    if (x)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (y)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (res)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(signextend_ocall_args_t));
    if (res)
        OE_ADD_SIZE(_output_buffer_size, 100);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (signextend_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (x)
        OE_WRITE_IN_PARAM(x, 100, unsigned char*);
    if (y)
        OE_WRITE_IN_PARAM(y, 100, unsigned char*);
    if (res)
        OE_WRITE_IN_OUT_PARAM(res, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_signextend_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (signextend_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(res, (size_t)(100));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t lt_ocall(
    unsigned char* x,
    unsigned char* y,
    unsigned char* res)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    lt_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.x = (unsigned char*)x;
    _args.y = (unsigned char*)y;
    _args.res = (unsigned char*)res;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(lt_ocall_args_t));
    if (x)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (y)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (res)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(lt_ocall_args_t));
    if (res)
        OE_ADD_SIZE(_output_buffer_size, 100);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (lt_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (x)
        OE_WRITE_IN_PARAM(x, 100, unsigned char*);
    if (y)
        OE_WRITE_IN_PARAM(y, 100, unsigned char*);
    if (res)
        OE_WRITE_IN_OUT_PARAM(res, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_lt_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (lt_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(res, (size_t)(100));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t gt_ocall(
    unsigned char* x,
    unsigned char* y,
    unsigned char* res)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    gt_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.x = (unsigned char*)x;
    _args.y = (unsigned char*)y;
    _args.res = (unsigned char*)res;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(gt_ocall_args_t));
    if (x)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (y)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (res)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(gt_ocall_args_t));
    if (res)
        OE_ADD_SIZE(_output_buffer_size, 100);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (gt_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (x)
        OE_WRITE_IN_PARAM(x, 100, unsigned char*);
    if (y)
        OE_WRITE_IN_PARAM(y, 100, unsigned char*);
    if (res)
        OE_WRITE_IN_OUT_PARAM(res, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_gt_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (gt_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(res, (size_t)(100));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t slt_ocall(
    unsigned char* x,
    unsigned char* y,
    unsigned char* res)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    slt_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.x = (unsigned char*)x;
    _args.y = (unsigned char*)y;
    _args.res = (unsigned char*)res;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(slt_ocall_args_t));
    if (x)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (y)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (res)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(slt_ocall_args_t));
    if (res)
        OE_ADD_SIZE(_output_buffer_size, 100);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (slt_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (x)
        OE_WRITE_IN_PARAM(x, 100, unsigned char*);
    if (y)
        OE_WRITE_IN_PARAM(y, 100, unsigned char*);
    if (res)
        OE_WRITE_IN_OUT_PARAM(res, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_slt_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (slt_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(res, (size_t)(100));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t eq_ocall(
    unsigned char* x,
    unsigned char* y,
    unsigned char* res)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    eq_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.x = (unsigned char*)x;
    _args.y = (unsigned char*)y;
    _args.res = (unsigned char*)res;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(eq_ocall_args_t));
    if (x)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (y)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (res)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(eq_ocall_args_t));
    if (res)
        OE_ADD_SIZE(_output_buffer_size, 100);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (eq_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (x)
        OE_WRITE_IN_PARAM(x, 100, unsigned char*);
    if (y)
        OE_WRITE_IN_PARAM(y, 100, unsigned char*);
    if (res)
        OE_WRITE_IN_OUT_PARAM(res, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_eq_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (eq_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(res, (size_t)(100));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t isZero_ocall(
    unsigned char* x,
    unsigned char* res)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    isZero_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.x = (unsigned char*)x;
    _args.res = (unsigned char*)res;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(isZero_ocall_args_t));
    if (x)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (res)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(isZero_ocall_args_t));
    if (res)
        OE_ADD_SIZE(_output_buffer_size, 100);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (isZero_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (x)
        OE_WRITE_IN_PARAM(x, 100, unsigned char*);
    if (res)
        OE_WRITE_IN_OUT_PARAM(res, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_isZero_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (isZero_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(res, (size_t)(100));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t and_ocall(
    unsigned char* x,
    unsigned char* y,
    unsigned char* res)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    and_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.x = (unsigned char*)x;
    _args.y = (unsigned char*)y;
    _args.res = (unsigned char*)res;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(and_ocall_args_t));
    if (x)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (y)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (res)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(and_ocall_args_t));
    if (res)
        OE_ADD_SIZE(_output_buffer_size, 100);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (and_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (x)
        OE_WRITE_IN_PARAM(x, 100, unsigned char*);
    if (y)
        OE_WRITE_IN_PARAM(y, 100, unsigned char*);
    if (res)
        OE_WRITE_IN_OUT_PARAM(res, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_and_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (and_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(res, (size_t)(100));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t or_ocall(
    unsigned char* x,
    unsigned char* y,
    unsigned char* res)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    or_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.x = (unsigned char*)x;
    _args.y = (unsigned char*)y;
    _args.res = (unsigned char*)res;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(or_ocall_args_t));
    if (x)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (y)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (res)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(or_ocall_args_t));
    if (res)
        OE_ADD_SIZE(_output_buffer_size, 100);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (or_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (x)
        OE_WRITE_IN_PARAM(x, 100, unsigned char*);
    if (y)
        OE_WRITE_IN_PARAM(y, 100, unsigned char*);
    if (res)
        OE_WRITE_IN_OUT_PARAM(res, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_or_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (or_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(res, (size_t)(100));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t xor_ocall(
    unsigned char* x,
    unsigned char* y,
    unsigned char* res)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    xor_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.x = (unsigned char*)x;
    _args.y = (unsigned char*)y;
    _args.res = (unsigned char*)res;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(xor_ocall_args_t));
    if (x)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (y)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (res)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(xor_ocall_args_t));
    if (res)
        OE_ADD_SIZE(_output_buffer_size, 100);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (xor_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (x)
        OE_WRITE_IN_PARAM(x, 100, unsigned char*);
    if (y)
        OE_WRITE_IN_PARAM(y, 100, unsigned char*);
    if (res)
        OE_WRITE_IN_OUT_PARAM(res, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_xor_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (xor_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(res, (size_t)(100));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t not_ocall(
    unsigned char* x,
    unsigned char* res)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    not_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.x = (unsigned char*)x;
    _args.res = (unsigned char*)res;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(not_ocall_args_t));
    if (x)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (res)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(not_ocall_args_t));
    if (res)
        OE_ADD_SIZE(_output_buffer_size, 100);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (not_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (x)
        OE_WRITE_IN_PARAM(x, 100, unsigned char*);
    if (res)
        OE_WRITE_IN_OUT_PARAM(res, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_not_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (not_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(res, (size_t)(100));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t byte_ocall(
    unsigned char* idx,
    unsigned char* val,
    unsigned char* res)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    byte_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.idx = (unsigned char*)idx;
    _args.val = (unsigned char*)val;
    _args.res = (unsigned char*)res;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(byte_ocall_args_t));
    if (idx)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (val)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (res)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(byte_ocall_args_t));
    if (res)
        OE_ADD_SIZE(_output_buffer_size, 100);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (byte_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (idx)
        OE_WRITE_IN_PARAM(idx, 100, unsigned char*);
    if (val)
        OE_WRITE_IN_PARAM(val, 100, unsigned char*);
    if (res)
        OE_WRITE_IN_OUT_PARAM(res, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_byte_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (byte_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(res, (size_t)(100));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t shl_ocall(
    unsigned char* x,
    unsigned char* y,
    unsigned char* res)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    shl_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.x = (unsigned char*)x;
    _args.y = (unsigned char*)y;
    _args.res = (unsigned char*)res;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(shl_ocall_args_t));
    if (x)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (y)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (res)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(shl_ocall_args_t));
    if (res)
        OE_ADD_SIZE(_output_buffer_size, 100);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (shl_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (x)
        OE_WRITE_IN_PARAM(x, 100, unsigned char*);
    if (y)
        OE_WRITE_IN_PARAM(y, 100, unsigned char*);
    if (res)
        OE_WRITE_IN_OUT_PARAM(res, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_shl_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (shl_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(res, (size_t)(100));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t shr_ocall(
    unsigned char* x,
    unsigned char* y,
    unsigned char* res)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    shr_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.x = (unsigned char*)x;
    _args.y = (unsigned char*)y;
    _args.res = (unsigned char*)res;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(shr_ocall_args_t));
    if (x)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (y)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (res)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(shr_ocall_args_t));
    if (res)
        OE_ADD_SIZE(_output_buffer_size, 100);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (shr_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (x)
        OE_WRITE_IN_PARAM(x, 100, unsigned char*);
    if (y)
        OE_WRITE_IN_PARAM(y, 100, unsigned char*);
    if (res)
        OE_WRITE_IN_OUT_PARAM(res, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_shr_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (shr_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(res, (size_t)(100));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t mstore8_ocall(
    uint8_t* b,
    unsigned char* n)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    mstore8_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.b = (uint8_t*)b;
    _args.n = (unsigned char*)n;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(mstore8_ocall_args_t));
    if (b)
        OE_ADD_SIZE(_input_buffer_size, sizeof(uint8_t));
    if (n)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(mstore8_ocall_args_t));
    if (b)
        OE_ADD_SIZE(_output_buffer_size, sizeof(uint8_t));
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (mstore8_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (b)
        OE_WRITE_IN_OUT_PARAM(b, sizeof(uint8_t), uint8_t*);
    if (n)
        OE_WRITE_IN_PARAM(n, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_mstore8_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (mstore8_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(b, (size_t)(sizeof(uint8_t)));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t calldataload_ocall(
    uint64_t offset,
    uint64_t sizeInput,
    uint8_t* input,
    size_t input_size,
    unsigned char* res)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    calldataload_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.offset = offset;
    _args.sizeInput = sizeInput;
    _args.input = (uint8_t*)input;
    _args.input_size = input_size;
    _args.res = (unsigned char*)res;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(calldataload_ocall_args_t));
    if (input)
        OE_ADD_SIZE(_input_buffer_size, _args.input_size);
    if (res)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(calldataload_ocall_args_t));
    if (res)
        OE_ADD_SIZE(_output_buffer_size, 100);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (calldataload_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (input)
        OE_WRITE_IN_PARAM(input, _args.input_size, uint8_t*);
    if (res)
        OE_WRITE_IN_OUT_PARAM(res, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_calldataload_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (calldataload_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(res, (size_t)(100));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t blockhash_ocall(
    unsigned char* x,
    unsigned char* res)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    blockhash_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.x = (unsigned char*)x;
    _args.res = (unsigned char*)res;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(blockhash_ocall_args_t));
    if (x)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (res)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(blockhash_ocall_args_t));
    if (res)
        OE_ADD_SIZE(_output_buffer_size, 100);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (blockhash_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (x)
        OE_WRITE_IN_PARAM(x, 100, unsigned char*);
    if (res)
        OE_WRITE_IN_OUT_PARAM(res, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_blockhash_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (blockhash_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(res, (size_t)(100));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t sha3_ocall(
    uint8_t* h,
    unsigned char* res)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    sha3_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.h = (uint8_t*)h;
    _args.res = (unsigned char*)res;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(sha3_ocall_args_t));
    if (h)
        OE_ADD_SIZE(_input_buffer_size, 32);
    if (res)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(sha3_ocall_args_t));
    if (h)
        OE_ADD_SIZE(_output_buffer_size, 32);
    if (res)
        OE_ADD_SIZE(_output_buffer_size, 100);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (sha3_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (h)
        OE_WRITE_IN_OUT_PARAM(h, 32, uint8_t*);
    if (res)
        OE_WRITE_IN_OUT_PARAM(res, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_sha3_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (sha3_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(h, (size_t)(32));
    OE_READ_IN_OUT_PARAM(res, (size_t)(100));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t generate_address_ocall(
    unsigned char* sender,
    size_t nonce,
    unsigned char* newAddress)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    generate_address_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.sender = (unsigned char*)sender;
    _args.nonce = nonce;
    _args.newAddress = (unsigned char*)newAddress;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(generate_address_ocall_args_t));
    if (sender)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (newAddress)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(generate_address_ocall_args_t));
    if (newAddress)
        OE_ADD_SIZE(_output_buffer_size, 100);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (generate_address_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (sender)
        OE_WRITE_IN_PARAM(sender, 100, unsigned char*);
    if (newAddress)
        OE_WRITE_IN_OUT_PARAM(newAddress, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_generate_address_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (generate_address_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(newAddress, (size_t)(100));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t to_big_endian_ocall(
    unsigned char* v,
    uint8_t* out,
    size_t out_size)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    to_big_endian_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.v = (unsigned char*)v;
    _args.out = (uint8_t*)out;
    _args.out_size = out_size;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(to_big_endian_ocall_args_t));
    if (v)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (out)
        OE_ADD_SIZE(_input_buffer_size, _args.out_size);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(to_big_endian_ocall_args_t));
    if (out)
        OE_ADD_SIZE(_output_buffer_size, _args.out_size);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (to_big_endian_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (v)
        OE_WRITE_IN_PARAM(v, 100, unsigned char*);
    if (out)
        OE_WRITE_IN_OUT_PARAM(out, _args.out_size, uint8_t*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_to_big_endian_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (to_big_endian_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(out, (size_t)(_args.out_size));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t from_big_endian_ocall(
    uint8_t* begin,
    size_t size,
    size_t begin_size,
    unsigned char* res)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    from_big_endian_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.begin = (uint8_t*)begin;
    _args.size = size;
    _args.begin_size = begin_size;
    _args.res = (unsigned char*)res;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(from_big_endian_ocall_args_t));
    if (begin)
        OE_ADD_SIZE(_input_buffer_size, _args.begin_size);
    if (res)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(from_big_endian_ocall_args_t));
    if (begin)
        OE_ADD_SIZE(_output_buffer_size, _args.begin_size);
    if (res)
        OE_ADD_SIZE(_output_buffer_size, 100);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (from_big_endian_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (begin)
        OE_WRITE_IN_OUT_PARAM(begin, _args.begin_size, uint8_t*);
    if (res)
        OE_WRITE_IN_OUT_PARAM(res, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_from_big_endian_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (from_big_endian_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(begin, (size_t)(_args.begin_size));
    OE_READ_IN_OUT_PARAM(res, (size_t)(100));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t oe_sgx_get_cpuid_table_ocall(
    oe_result_t* _retval,
    void* cpuid_table_buffer,
    size_t cpuid_table_buffer_size)
{
    oe_result_t _result = OE_FAILURE;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
       immediately. */
    if (oe_get_enclave_status() != OE_OK)
        return oe_get_enclave_status();

    /* Marshalling struct. */
    oe_sgx_get_cpuid_table_ocall_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.cpuid_table_buffer = (void*)cpuid_table_buffer;
    _args.cpuid_table_buffer_size = cpuid_table_buffer_size;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(oe_sgx_get_cpuid_table_ocall_args_t));
    /* There were no corresponding parameters. */
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(oe_sgx_get_cpuid_table_ocall_args_t));
    if (cpuid_table_buffer)
        OE_ADD_SIZE(_output_buffer_size, _args.cpuid_table_buffer_size);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (oe_sgx_get_cpuid_table_ocall_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    /* There were no in nor in-out parameters. */
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function. */
    if ((_result = oe_call_host_function(
             enclave_fcn_id_oe_sgx_get_cpuid_table_ocall,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (oe_sgx_get_cpuid_table_ocall_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    *_retval = _pargs_out->_retval;
    OE_READ_OUT_PARAM(cpuid_table_buffer, (size_t)(_args.cpuid_table_buffer_size));

    /* Retrieve propagated errno from OCALL. */
    /* Errno propagation not enabled. */

    _result = OE_OK;

done:
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

OE_EXTERNC_END
