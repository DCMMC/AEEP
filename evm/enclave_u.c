/*
 *  This file is auto generated by oeedger8r. DO NOT EDIT.
 */
#include "enclave_u.h"

#include <openenclave/edger8r/host.h>

OE_EXTERNC_BEGIN

/**** Trusted function IDs. ****/
enum
{
    enclave_fcn_id_enclave_run = 0,
    enclave_fcn_id_enclave_deploy = 1,
    enclave_fcn_id_trusted_call_id_max = OE_ENUM_MAX
};

/**** Trusted function names. ****/
static const oe_ecall_info_t __enclave_ecall_info_table[] = 
{
    { "enclave_run" },
    { "enclave_deploy" },
};

/**** ECALL marshalling structs. ****/
typedef struct _enclave_run_args_t
{
    oe_result_t _result;
    exec_result_struct* result;
    gs_struct* _gs;
    tx_struct* _tx;
    unsigned char* _caller;
    unsigned char* _callee;
    uint8_t* _input;
    size_t _input_size;
    unsigned char* _call_value;
} enclave_run_args_t;

typedef struct _enclave_deploy_args_t
{
    oe_result_t _result;
    gs_struct* _gs;
    tx_struct* _tx;
    unsigned char* _caller;
    uint8_t* _constructor;
    size_t _constructor_size;
    unsigned char* contract_address;
} enclave_deploy_args_t;

/**** ECALL function wrappers. ****/

oe_result_t enclave_enclave_run(
    oe_enclave_t* enclave,
    exec_result_struct* result,
    gs_struct* _gs,
    tx_struct* _tx,
    unsigned char* _caller,
    unsigned char* _callee,
    uint8_t* _input,
    size_t _input_size,
    unsigned char* _call_value)
{
    oe_result_t _result = OE_FAILURE;

    static uint64_t global_id = OE_GLOBAL_ECALL_ID_NULL;

    /* Marshalling struct. */
    enclave_run_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args.result = (exec_result_struct*)result;
    _args._gs = (gs_struct*)_gs;
    _args._tx = (tx_struct*)_tx;
    _args._caller = (unsigned char*)_caller;
    _args._callee = (unsigned char*)_callee;
    _args._input = (uint8_t*)_input;
    _args._input_size = _input_size;
    _args._call_value = (unsigned char*)_call_value;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(enclave_run_args_t));
    if (result)
        OE_ADD_SIZE(_input_buffer_size, sizeof(exec_result_struct));
    if (_gs)
        OE_ADD_SIZE(_input_buffer_size, sizeof(gs_struct));
    if (_tx)
        OE_ADD_SIZE(_input_buffer_size, sizeof(tx_struct));
    if (_caller)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (_callee)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (_input)
        OE_ADD_SIZE(_input_buffer_size, _args._input_size);
    if (_call_value)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(enclave_run_args_t));
    if (result)
        OE_ADD_SIZE(_output_buffer_size, sizeof(exec_result_struct));
    if (_gs)
        OE_ADD_SIZE(_output_buffer_size, sizeof(gs_struct));
    if (_tx)
        OE_ADD_SIZE(_output_buffer_size, sizeof(tx_struct));
    if (_caller)
        OE_ADD_SIZE(_output_buffer_size, 100);
    if (_callee)
        OE_ADD_SIZE(_output_buffer_size, 100);
    if (_input)
        OE_ADD_SIZE(_output_buffer_size, _args._input_size);
    if (_call_value)
        OE_ADD_SIZE(_output_buffer_size, 100);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_malloc(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (enclave_run_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (result)
        OE_WRITE_IN_OUT_PARAM(result, sizeof(exec_result_struct), exec_result_struct*);
    if (_gs)
        OE_WRITE_IN_OUT_PARAM(_gs, sizeof(gs_struct), gs_struct*);
    if (_tx)
        OE_WRITE_IN_OUT_PARAM(_tx, sizeof(tx_struct), tx_struct*);
    if (_caller)
        OE_WRITE_IN_OUT_PARAM(_caller, 100, unsigned char*);
    if (_callee)
        OE_WRITE_IN_OUT_PARAM(_callee, 100, unsigned char*);
    if (_input)
        OE_WRITE_IN_OUT_PARAM(_input, _args._input_size, uint8_t*);
    if (_call_value)
        OE_WRITE_IN_OUT_PARAM(_call_value, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call enclave function. */
    if ((_result = oe_call_enclave_function(
             enclave,
             &global_id,
             __enclave_ecall_info_table[enclave_fcn_id_enclave_run].name,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (enclave_run_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(result, (size_t)(sizeof(exec_result_struct)));
    OE_READ_IN_OUT_PARAM(_gs, (size_t)(sizeof(gs_struct)));
    OE_READ_IN_OUT_PARAM(_tx, (size_t)(sizeof(tx_struct)));
    OE_READ_IN_OUT_PARAM(_caller, (size_t)(100));
    OE_READ_IN_OUT_PARAM(_callee, (size_t)(100));
    OE_READ_IN_OUT_PARAM(_input, (size_t)(_args._input_size));
    OE_READ_IN_OUT_PARAM(_call_value, (size_t)(100));

    _result = OE_OK;

done:
    if (_buffer)
        free(_buffer);

    return _result;
}

OE_WEAK_ALIAS(enclave_enclave_run, enclave_run);

oe_result_t enclave_enclave_deploy(
    oe_enclave_t* enclave,
    gs_struct* _gs,
    tx_struct* _tx,
    unsigned char* _caller,
    uint8_t* _constructor,
    size_t _constructor_size,
    unsigned char* contract_address)
{
    oe_result_t _result = OE_FAILURE;

    static uint64_t global_id = OE_GLOBAL_ECALL_ID_NULL;

    /* Marshalling struct. */
    enclave_deploy_args_t _args, *_pargs_in = NULL, *_pargs_out = NULL;
    /* Marshalling buffer and sizes. */
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshalling struct. */
    memset(&_args, 0, sizeof(_args));
    _args._gs = (gs_struct*)_gs;
    _args._tx = (tx_struct*)_tx;
    _args._caller = (unsigned char*)_caller;
    _args._constructor = (uint8_t*)_constructor;
    _args._constructor_size = _constructor_size;
    _args.contract_address = (unsigned char*)contract_address;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(enclave_deploy_args_t));
    if (_gs)
        OE_ADD_SIZE(_input_buffer_size, sizeof(gs_struct));
    if (_tx)
        OE_ADD_SIZE(_input_buffer_size, sizeof(tx_struct));
    if (_caller)
        OE_ADD_SIZE(_input_buffer_size, 100);
    if (_constructor)
        OE_ADD_SIZE(_input_buffer_size, _args._constructor_size);
    if (contract_address)
        OE_ADD_SIZE(_input_buffer_size, 100);
    
    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(enclave_deploy_args_t));
    if (_gs)
        OE_ADD_SIZE(_output_buffer_size, sizeof(gs_struct));
    if (_tx)
        OE_ADD_SIZE(_output_buffer_size, sizeof(tx_struct));
    if (_caller)
        OE_ADD_SIZE(_output_buffer_size, 100);
    if (_constructor)
        OE_ADD_SIZE(_output_buffer_size, _args._constructor_size);
    if (contract_address)
        OE_ADD_SIZE(_output_buffer_size, 100);
    
    /* Allocate marshalling buffer. */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);
    _buffer = (uint8_t*)oe_malloc(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL)
    {
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }
    
    /* Serialize buffer inputs (in and in-out parameters). */
    _pargs_in = (enclave_deploy_args_t*)_input_buffer;
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));
    if (_gs)
        OE_WRITE_IN_OUT_PARAM(_gs, sizeof(gs_struct), gs_struct*);
    if (_tx)
        OE_WRITE_IN_OUT_PARAM(_tx, sizeof(tx_struct), tx_struct*);
    if (_caller)
        OE_WRITE_IN_OUT_PARAM(_caller, 100, unsigned char*);
    if (_constructor)
        OE_WRITE_IN_OUT_PARAM(_constructor, _args._constructor_size, uint8_t*);
    if (contract_address)
        OE_WRITE_IN_OUT_PARAM(contract_address, 100, unsigned char*);
    
    /* Copy args structure (now filled) to input buffer. */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call enclave function. */
    if ((_result = oe_call_enclave_function(
             enclave,
             &global_id,
             __enclave_ecall_info_table[enclave_fcn_id_enclave_deploy].name,
             _input_buffer,
             _input_buffer_size,
             _output_buffer,
             _output_buffer_size,
             &_output_bytes_written)) != OE_OK)
        goto done;

    /* Setup output arg struct pointer. */
    _pargs_out = (enclave_deploy_args_t*)_output_buffer;
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));
    
    /* Check if the call succeeded. */
    if ((_result = _pargs_out->_result) != OE_OK)
        goto done;
    
    /* Currently exactly _output_buffer_size bytes must be written. */
    if (_output_bytes_written != _output_buffer_size)
    {
        _result = OE_FAILURE;
        goto done;
    }
    
    /* Unmarshal return value and out, in-out parameters. */
    /* No return value. */
    OE_READ_IN_OUT_PARAM(_gs, (size_t)(sizeof(gs_struct)));
    OE_READ_IN_OUT_PARAM(_tx, (size_t)(sizeof(tx_struct)));
    OE_READ_IN_OUT_PARAM(_caller, (size_t)(100));
    OE_READ_IN_OUT_PARAM(_constructor, (size_t)(_args._constructor_size));
    OE_READ_IN_OUT_PARAM(contract_address, (size_t)(100));

    _result = OE_OK;

done:
    if (_buffer)
        free(_buffer);

    return _result;
}

OE_WEAK_ALIAS(enclave_enclave_deploy, enclave_deploy);

/**** Untrusted function IDs. ****/
enum
{
    enclave_fcn_id_push_ocall = 0,
    enclave_fcn_id_add_ocall = 1,
    enclave_fcn_id_mul_ocall = 2,
    enclave_fcn_id_sub_ocall = 3,
    enclave_fcn_id_div_ocall = 4,
    enclave_fcn_id_sdiv_ocall = 5,
    enclave_fcn_id_mod_ocall = 6,
    enclave_fcn_id_smod_ocall = 7,
    enclave_fcn_id_addmod_ocall = 8,
    enclave_fcn_id_mulmod_ocall = 9,
    enclave_fcn_id_exp_ocall = 10,
    enclave_fcn_id_signextend_ocall = 11,
    enclave_fcn_id_lt_ocall = 12,
    enclave_fcn_id_gt_ocall = 13,
    enclave_fcn_id_slt_ocall = 14,
    enclave_fcn_id_eq_ocall = 15,
    enclave_fcn_id_isZero_ocall = 16,
    enclave_fcn_id_and_ocall = 17,
    enclave_fcn_id_or_ocall = 18,
    enclave_fcn_id_xor_ocall = 19,
    enclave_fcn_id_not_ocall = 20,
    enclave_fcn_id_byte_ocall = 21,
    enclave_fcn_id_shl_ocall = 22,
    enclave_fcn_id_shr_ocall = 23,
    enclave_fcn_id_mstore8_ocall = 24,
    enclave_fcn_id_calldataload_ocall = 25,
    enclave_fcn_id_blockhash_ocall = 26,
    enclave_fcn_id_sha3_ocall = 27,
    enclave_fcn_id_generate_address_ocall = 28,
    enclave_fcn_id_to_big_endian_ocall = 29,
    enclave_fcn_id_from_big_endian_ocall = 30,
    enclave_fcn_id_oe_sgx_get_cpuid_table_ocall = 31,
    enclave_fcn_id_untrusted_call_max = OE_ENUM_MAX
};

/**** OCALL marshalling structs. ****/
typedef struct _push_ocall_args_t
{
    oe_result_t _result;
    uint64_t* pc;
    uint8_t bytes;
    uint8_t* code_arr;
    size_t code_size;
    unsigned char* res;
} push_ocall_args_t;

typedef struct _add_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} add_ocall_args_t;

typedef struct _mul_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} mul_ocall_args_t;

typedef struct _sub_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} sub_ocall_args_t;

typedef struct _div_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} div_ocall_args_t;

typedef struct _sdiv_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} sdiv_ocall_args_t;

typedef struct _mod_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} mod_ocall_args_t;

typedef struct _smod_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} smod_ocall_args_t;

typedef struct _addmod_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* m;
    unsigned char* res;
} addmod_ocall_args_t;

typedef struct _mulmod_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* m;
    unsigned char* res;
} mulmod_ocall_args_t;

typedef struct _exp_ocall_args_t
{
    oe_result_t _result;
    unsigned char* b;
    unsigned char* e;
    unsigned char* res;
} exp_ocall_args_t;

typedef struct _signextend_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} signextend_ocall_args_t;

typedef struct _lt_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} lt_ocall_args_t;

typedef struct _gt_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} gt_ocall_args_t;

typedef struct _slt_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} slt_ocall_args_t;

typedef struct _eq_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} eq_ocall_args_t;

typedef struct _isZero_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* res;
} isZero_ocall_args_t;

typedef struct _and_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} and_ocall_args_t;

typedef struct _or_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} or_ocall_args_t;

typedef struct _xor_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} xor_ocall_args_t;

typedef struct _not_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* res;
} not_ocall_args_t;

typedef struct _byte_ocall_args_t
{
    oe_result_t _result;
    unsigned char* idx;
    unsigned char* val;
    unsigned char* res;
} byte_ocall_args_t;

typedef struct _shl_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} shl_ocall_args_t;

typedef struct _shr_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* y;
    unsigned char* res;
} shr_ocall_args_t;

typedef struct _mstore8_ocall_args_t
{
    oe_result_t _result;
    uint8_t* b;
    unsigned char* n;
} mstore8_ocall_args_t;

typedef struct _calldataload_ocall_args_t
{
    oe_result_t _result;
    uint64_t offset;
    uint64_t sizeInput;
    uint8_t* input;
    size_t input_size;
    unsigned char* res;
} calldataload_ocall_args_t;

typedef struct _blockhash_ocall_args_t
{
    oe_result_t _result;
    unsigned char* x;
    unsigned char* res;
} blockhash_ocall_args_t;

typedef struct _sha3_ocall_args_t
{
    oe_result_t _result;
    uint8_t* h;
    unsigned char* res;
} sha3_ocall_args_t;

typedef struct _generate_address_ocall_args_t
{
    oe_result_t _result;
    unsigned char* sender;
    size_t nonce;
    unsigned char* newAddress;
} generate_address_ocall_args_t;

typedef struct _to_big_endian_ocall_args_t
{
    oe_result_t _result;
    unsigned char* v;
    uint8_t* out;
    size_t out_size;
} to_big_endian_ocall_args_t;

typedef struct _from_big_endian_ocall_args_t
{
    oe_result_t _result;
    uint8_t* begin;
    size_t size;
    size_t begin_size;
    unsigned char* res;
} from_big_endian_ocall_args_t;

typedef struct _oe_sgx_get_cpuid_table_ocall_args_t
{
    oe_result_t _result;
    oe_result_t _retval;
    void* cpuid_table_buffer;
    size_t cpuid_table_buffer_size;
} oe_sgx_get_cpuid_table_ocall_args_t;

/**** OCALL functions. ****/

static void ocall_push_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    push_ocall_args_t* pargs_in = (push_ocall_args_t*)input_buffer;
    push_ocall_args_t* pargs_out = (push_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->pc)
        OE_SET_IN_OUT_POINTER(pc, sizeof(uint64_t), uint64_t*);
    if (pargs_in->code_arr)
        OE_SET_IN_OUT_POINTER(code_arr, pargs_in->code_size, uint8_t*);
    if (pargs_in->res)
        OE_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->pc)
        OE_COPY_AND_SET_IN_OUT_POINTER(pc, sizeof(uint64_t), uint64_t*);
    if (pargs_in->code_arr)
        OE_COPY_AND_SET_IN_OUT_POINTER(code_arr, pargs_in->code_size, uint8_t*);
    if (pargs_in->res)
        OE_COPY_AND_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Call user function. */
    push_ocall(
        pargs_in->pc,
        pargs_in->bytes,
        pargs_in->code_arr,
        pargs_in->code_size,
        pargs_in->res);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_add_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    add_ocall_args_t* pargs_in = (add_ocall_args_t*)input_buffer;
    add_ocall_args_t* pargs_out = (add_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->x)
        OE_SET_IN_POINTER(x, 100, unsigned char*);
    if (pargs_in->y)
        OE_SET_IN_POINTER(y, 100, unsigned char*);
    if (pargs_in->res)
        OE_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->res)
        OE_COPY_AND_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Call user function. */
    add_ocall(
        pargs_in->x,
        pargs_in->y,
        pargs_in->res);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_mul_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    mul_ocall_args_t* pargs_in = (mul_ocall_args_t*)input_buffer;
    mul_ocall_args_t* pargs_out = (mul_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->x)
        OE_SET_IN_POINTER(x, 100, unsigned char*);
    if (pargs_in->y)
        OE_SET_IN_POINTER(y, 100, unsigned char*);
    if (pargs_in->res)
        OE_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->res)
        OE_COPY_AND_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Call user function. */
    mul_ocall(
        pargs_in->x,
        pargs_in->y,
        pargs_in->res);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_sub_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    sub_ocall_args_t* pargs_in = (sub_ocall_args_t*)input_buffer;
    sub_ocall_args_t* pargs_out = (sub_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->x)
        OE_SET_IN_POINTER(x, 100, unsigned char*);
    if (pargs_in->y)
        OE_SET_IN_POINTER(y, 100, unsigned char*);
    if (pargs_in->res)
        OE_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->res)
        OE_COPY_AND_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Call user function. */
    sub_ocall(
        pargs_in->x,
        pargs_in->y,
        pargs_in->res);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_div_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    div_ocall_args_t* pargs_in = (div_ocall_args_t*)input_buffer;
    div_ocall_args_t* pargs_out = (div_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->x)
        OE_SET_IN_POINTER(x, 100, unsigned char*);
    if (pargs_in->y)
        OE_SET_IN_POINTER(y, 100, unsigned char*);
    if (pargs_in->res)
        OE_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->res)
        OE_COPY_AND_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Call user function. */
    div_ocall(
        pargs_in->x,
        pargs_in->y,
        pargs_in->res);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_sdiv_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    sdiv_ocall_args_t* pargs_in = (sdiv_ocall_args_t*)input_buffer;
    sdiv_ocall_args_t* pargs_out = (sdiv_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->x)
        OE_SET_IN_POINTER(x, 100, unsigned char*);
    if (pargs_in->y)
        OE_SET_IN_POINTER(y, 100, unsigned char*);
    if (pargs_in->res)
        OE_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->res)
        OE_COPY_AND_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Call user function. */
    sdiv_ocall(
        pargs_in->x,
        pargs_in->y,
        pargs_in->res);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_mod_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    mod_ocall_args_t* pargs_in = (mod_ocall_args_t*)input_buffer;
    mod_ocall_args_t* pargs_out = (mod_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->x)
        OE_SET_IN_POINTER(x, 100, unsigned char*);
    if (pargs_in->y)
        OE_SET_IN_POINTER(y, 100, unsigned char*);
    if (pargs_in->res)
        OE_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->res)
        OE_COPY_AND_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Call user function. */
    mod_ocall(
        pargs_in->x,
        pargs_in->y,
        pargs_in->res);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_smod_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    smod_ocall_args_t* pargs_in = (smod_ocall_args_t*)input_buffer;
    smod_ocall_args_t* pargs_out = (smod_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->x)
        OE_SET_IN_POINTER(x, 100, unsigned char*);
    if (pargs_in->y)
        OE_SET_IN_POINTER(y, 100, unsigned char*);
    if (pargs_in->res)
        OE_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->res)
        OE_COPY_AND_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Call user function. */
    smod_ocall(
        pargs_in->x,
        pargs_in->y,
        pargs_in->res);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_addmod_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    addmod_ocall_args_t* pargs_in = (addmod_ocall_args_t*)input_buffer;
    addmod_ocall_args_t* pargs_out = (addmod_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->x)
        OE_SET_IN_POINTER(x, 100, unsigned char*);
    if (pargs_in->y)
        OE_SET_IN_POINTER(y, 100, unsigned char*);
    if (pargs_in->m)
        OE_SET_IN_POINTER(m, 100, unsigned char*);
    if (pargs_in->res)
        OE_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->res)
        OE_COPY_AND_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Call user function. */
    addmod_ocall(
        pargs_in->x,
        pargs_in->y,
        pargs_in->m,
        pargs_in->res);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_mulmod_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    mulmod_ocall_args_t* pargs_in = (mulmod_ocall_args_t*)input_buffer;
    mulmod_ocall_args_t* pargs_out = (mulmod_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->x)
        OE_SET_IN_POINTER(x, 100, unsigned char*);
    if (pargs_in->y)
        OE_SET_IN_POINTER(y, 100, unsigned char*);
    if (pargs_in->m)
        OE_SET_IN_POINTER(m, 100, unsigned char*);
    if (pargs_in->res)
        OE_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->res)
        OE_COPY_AND_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Call user function. */
    mulmod_ocall(
        pargs_in->x,
        pargs_in->y,
        pargs_in->m,
        pargs_in->res);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_exp_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    exp_ocall_args_t* pargs_in = (exp_ocall_args_t*)input_buffer;
    exp_ocall_args_t* pargs_out = (exp_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->b)
        OE_SET_IN_POINTER(b, 100, unsigned char*);
    if (pargs_in->e)
        OE_SET_IN_POINTER(e, 100, unsigned char*);
    if (pargs_in->res)
        OE_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->res)
        OE_COPY_AND_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Call user function. */
    exp_ocall(
        pargs_in->b,
        pargs_in->e,
        pargs_in->res);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_signextend_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    signextend_ocall_args_t* pargs_in = (signextend_ocall_args_t*)input_buffer;
    signextend_ocall_args_t* pargs_out = (signextend_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->x)
        OE_SET_IN_POINTER(x, 100, unsigned char*);
    if (pargs_in->y)
        OE_SET_IN_POINTER(y, 100, unsigned char*);
    if (pargs_in->res)
        OE_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->res)
        OE_COPY_AND_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Call user function. */
    signextend_ocall(
        pargs_in->x,
        pargs_in->y,
        pargs_in->res);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_lt_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    lt_ocall_args_t* pargs_in = (lt_ocall_args_t*)input_buffer;
    lt_ocall_args_t* pargs_out = (lt_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->x)
        OE_SET_IN_POINTER(x, 100, unsigned char*);
    if (pargs_in->y)
        OE_SET_IN_POINTER(y, 100, unsigned char*);
    if (pargs_in->res)
        OE_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->res)
        OE_COPY_AND_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Call user function. */
    lt_ocall(
        pargs_in->x,
        pargs_in->y,
        pargs_in->res);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_gt_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    gt_ocall_args_t* pargs_in = (gt_ocall_args_t*)input_buffer;
    gt_ocall_args_t* pargs_out = (gt_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->x)
        OE_SET_IN_POINTER(x, 100, unsigned char*);
    if (pargs_in->y)
        OE_SET_IN_POINTER(y, 100, unsigned char*);
    if (pargs_in->res)
        OE_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->res)
        OE_COPY_AND_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Call user function. */
    gt_ocall(
        pargs_in->x,
        pargs_in->y,
        pargs_in->res);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_slt_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    slt_ocall_args_t* pargs_in = (slt_ocall_args_t*)input_buffer;
    slt_ocall_args_t* pargs_out = (slt_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->x)
        OE_SET_IN_POINTER(x, 100, unsigned char*);
    if (pargs_in->y)
        OE_SET_IN_POINTER(y, 100, unsigned char*);
    if (pargs_in->res)
        OE_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->res)
        OE_COPY_AND_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Call user function. */
    slt_ocall(
        pargs_in->x,
        pargs_in->y,
        pargs_in->res);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_eq_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    eq_ocall_args_t* pargs_in = (eq_ocall_args_t*)input_buffer;
    eq_ocall_args_t* pargs_out = (eq_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->x)
        OE_SET_IN_POINTER(x, 100, unsigned char*);
    if (pargs_in->y)
        OE_SET_IN_POINTER(y, 100, unsigned char*);
    if (pargs_in->res)
        OE_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->res)
        OE_COPY_AND_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Call user function. */
    eq_ocall(
        pargs_in->x,
        pargs_in->y,
        pargs_in->res);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_isZero_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    isZero_ocall_args_t* pargs_in = (isZero_ocall_args_t*)input_buffer;
    isZero_ocall_args_t* pargs_out = (isZero_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->x)
        OE_SET_IN_POINTER(x, 100, unsigned char*);
    if (pargs_in->res)
        OE_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->res)
        OE_COPY_AND_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Call user function. */
    isZero_ocall(
        pargs_in->x,
        pargs_in->res);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_and_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    and_ocall_args_t* pargs_in = (and_ocall_args_t*)input_buffer;
    and_ocall_args_t* pargs_out = (and_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->x)
        OE_SET_IN_POINTER(x, 100, unsigned char*);
    if (pargs_in->y)
        OE_SET_IN_POINTER(y, 100, unsigned char*);
    if (pargs_in->res)
        OE_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->res)
        OE_COPY_AND_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Call user function. */
    and_ocall(
        pargs_in->x,
        pargs_in->y,
        pargs_in->res);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_or_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    or_ocall_args_t* pargs_in = (or_ocall_args_t*)input_buffer;
    or_ocall_args_t* pargs_out = (or_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->x)
        OE_SET_IN_POINTER(x, 100, unsigned char*);
    if (pargs_in->y)
        OE_SET_IN_POINTER(y, 100, unsigned char*);
    if (pargs_in->res)
        OE_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->res)
        OE_COPY_AND_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Call user function. */
    or_ocall(
        pargs_in->x,
        pargs_in->y,
        pargs_in->res);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_xor_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    xor_ocall_args_t* pargs_in = (xor_ocall_args_t*)input_buffer;
    xor_ocall_args_t* pargs_out = (xor_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->x)
        OE_SET_IN_POINTER(x, 100, unsigned char*);
    if (pargs_in->y)
        OE_SET_IN_POINTER(y, 100, unsigned char*);
    if (pargs_in->res)
        OE_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->res)
        OE_COPY_AND_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Call user function. */
    xor_ocall(
        pargs_in->x,
        pargs_in->y,
        pargs_in->res);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_not_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    not_ocall_args_t* pargs_in = (not_ocall_args_t*)input_buffer;
    not_ocall_args_t* pargs_out = (not_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->x)
        OE_SET_IN_POINTER(x, 100, unsigned char*);
    if (pargs_in->res)
        OE_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->res)
        OE_COPY_AND_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Call user function. */
    not_ocall(
        pargs_in->x,
        pargs_in->res);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_byte_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    byte_ocall_args_t* pargs_in = (byte_ocall_args_t*)input_buffer;
    byte_ocall_args_t* pargs_out = (byte_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->idx)
        OE_SET_IN_POINTER(idx, 100, unsigned char*);
    if (pargs_in->val)
        OE_SET_IN_POINTER(val, 100, unsigned char*);
    if (pargs_in->res)
        OE_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->res)
        OE_COPY_AND_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Call user function. */
    byte_ocall(
        pargs_in->idx,
        pargs_in->val,
        pargs_in->res);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_shl_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    shl_ocall_args_t* pargs_in = (shl_ocall_args_t*)input_buffer;
    shl_ocall_args_t* pargs_out = (shl_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->x)
        OE_SET_IN_POINTER(x, 100, unsigned char*);
    if (pargs_in->y)
        OE_SET_IN_POINTER(y, 100, unsigned char*);
    if (pargs_in->res)
        OE_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->res)
        OE_COPY_AND_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Call user function. */
    shl_ocall(
        pargs_in->x,
        pargs_in->y,
        pargs_in->res);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_shr_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    shr_ocall_args_t* pargs_in = (shr_ocall_args_t*)input_buffer;
    shr_ocall_args_t* pargs_out = (shr_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->x)
        OE_SET_IN_POINTER(x, 100, unsigned char*);
    if (pargs_in->y)
        OE_SET_IN_POINTER(y, 100, unsigned char*);
    if (pargs_in->res)
        OE_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->res)
        OE_COPY_AND_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Call user function. */
    shr_ocall(
        pargs_in->x,
        pargs_in->y,
        pargs_in->res);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_mstore8_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    mstore8_ocall_args_t* pargs_in = (mstore8_ocall_args_t*)input_buffer;
    mstore8_ocall_args_t* pargs_out = (mstore8_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->b)
        OE_SET_IN_OUT_POINTER(b, sizeof(uint8_t), uint8_t*);
    if (pargs_in->n)
        OE_SET_IN_POINTER(n, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->b)
        OE_COPY_AND_SET_IN_OUT_POINTER(b, sizeof(uint8_t), uint8_t*);

    /* Call user function. */
    mstore8_ocall(
        pargs_in->b,
        pargs_in->n);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_calldataload_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    calldataload_ocall_args_t* pargs_in = (calldataload_ocall_args_t*)input_buffer;
    calldataload_ocall_args_t* pargs_out = (calldataload_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->input)
        OE_SET_IN_POINTER(input, pargs_in->input_size, uint8_t*);
    if (pargs_in->res)
        OE_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->res)
        OE_COPY_AND_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Call user function. */
    calldataload_ocall(
        pargs_in->offset,
        pargs_in->sizeInput,
        pargs_in->input,
        pargs_in->input_size,
        pargs_in->res);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_blockhash_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    blockhash_ocall_args_t* pargs_in = (blockhash_ocall_args_t*)input_buffer;
    blockhash_ocall_args_t* pargs_out = (blockhash_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->x)
        OE_SET_IN_POINTER(x, 100, unsigned char*);
    if (pargs_in->res)
        OE_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->res)
        OE_COPY_AND_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Call user function. */
    blockhash_ocall(
        pargs_in->x,
        pargs_in->res);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_sha3_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    sha3_ocall_args_t* pargs_in = (sha3_ocall_args_t*)input_buffer;
    sha3_ocall_args_t* pargs_out = (sha3_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->h)
        OE_SET_IN_OUT_POINTER(h, 32, uint8_t*);
    if (pargs_in->res)
        OE_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->h)
        OE_COPY_AND_SET_IN_OUT_POINTER(h, 32, uint8_t*);
    if (pargs_in->res)
        OE_COPY_AND_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Call user function. */
    sha3_ocall(
        pargs_in->h,
        pargs_in->res);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_generate_address_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    generate_address_ocall_args_t* pargs_in = (generate_address_ocall_args_t*)input_buffer;
    generate_address_ocall_args_t* pargs_out = (generate_address_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->sender)
        OE_SET_IN_POINTER(sender, 100, unsigned char*);
    if (pargs_in->newAddress)
        OE_SET_IN_OUT_POINTER(newAddress, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->newAddress)
        OE_COPY_AND_SET_IN_OUT_POINTER(newAddress, 100, unsigned char*);

    /* Call user function. */
    generate_address_ocall(
        pargs_in->sender,
        pargs_in->nonce,
        pargs_in->newAddress);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_to_big_endian_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    to_big_endian_ocall_args_t* pargs_in = (to_big_endian_ocall_args_t*)input_buffer;
    to_big_endian_ocall_args_t* pargs_out = (to_big_endian_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->v)
        OE_SET_IN_POINTER(v, 100, unsigned char*);
    if (pargs_in->out)
        OE_SET_IN_OUT_POINTER(out, pargs_in->out_size, uint8_t*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->out)
        OE_COPY_AND_SET_IN_OUT_POINTER(out, pargs_in->out_size, uint8_t*);

    /* Call user function. */
    to_big_endian_ocall(
        pargs_in->v,
        pargs_in->out,
        pargs_in->out_size);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_from_big_endian_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    from_big_endian_ocall_args_t* pargs_in = (from_big_endian_ocall_args_t*)input_buffer;
    from_big_endian_ocall_args_t* pargs_out = (from_big_endian_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    if (pargs_in->begin)
        OE_SET_IN_OUT_POINTER(begin, pargs_in->begin_size, uint8_t*);
    if (pargs_in->res)
        OE_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->begin)
        OE_COPY_AND_SET_IN_OUT_POINTER(begin, pargs_in->begin_size, uint8_t*);
    if (pargs_in->res)
        OE_COPY_AND_SET_IN_OUT_POINTER(res, 100, unsigned char*);

    /* Call user function. */
    from_big_endian_ocall(
        pargs_in->begin,
        pargs_in->size,
        pargs_in->begin_size,
        pargs_in->res);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

static void ocall_oe_sgx_get_cpuid_table_ocall(
    uint8_t* input_buffer,
    size_t input_buffer_size,
    uint8_t* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;
    OE_UNUSED(input_buffer_size);

    /* Prepare parameters. */
    oe_sgx_get_cpuid_table_ocall_args_t* pargs_in = (oe_sgx_get_cpuid_table_ocall_args_t*)input_buffer;
    oe_sgx_get_cpuid_table_ocall_args_t* pargs_out = (oe_sgx_get_cpuid_table_ocall_args_t*)output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers are valid. */
    if (!input_buffer || !output_buffer) {
        _result = OE_INVALID_PARAMETER;
        goto done;
    }

    /* Set in and in-out pointers. */
    /* There were no in nor in-out parameters. */

    /* Set out and in-out pointers. */
    /* In-out parameters are copied to output buffer. */
    if (pargs_in->cpuid_table_buffer)
        OE_SET_OUT_POINTER(cpuid_table_buffer, pargs_in->cpuid_table_buffer_size, void*);

    /* Call user function. */
    pargs_out->_retval = oe_sgx_get_cpuid_table_ocall(
        pargs_in->cpuid_table_buffer,
        pargs_in->cpuid_table_buffer_size);

    /* Propagate errno back to enclave. */
    /* Errno propagation not enabled. */

    /* Success. */
    _result = OE_OK;
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out))
        pargs_out->_result = _result;
}

/**** OCALL function table. ****/

static oe_ocall_func_t __enclave_ocall_function_table[] = {
    (oe_ocall_func_t) ocall_push_ocall,
    (oe_ocall_func_t) ocall_add_ocall,
    (oe_ocall_func_t) ocall_mul_ocall,
    (oe_ocall_func_t) ocall_sub_ocall,
    (oe_ocall_func_t) ocall_div_ocall,
    (oe_ocall_func_t) ocall_sdiv_ocall,
    (oe_ocall_func_t) ocall_mod_ocall,
    (oe_ocall_func_t) ocall_smod_ocall,
    (oe_ocall_func_t) ocall_addmod_ocall,
    (oe_ocall_func_t) ocall_mulmod_ocall,
    (oe_ocall_func_t) ocall_exp_ocall,
    (oe_ocall_func_t) ocall_signextend_ocall,
    (oe_ocall_func_t) ocall_lt_ocall,
    (oe_ocall_func_t) ocall_gt_ocall,
    (oe_ocall_func_t) ocall_slt_ocall,
    (oe_ocall_func_t) ocall_eq_ocall,
    (oe_ocall_func_t) ocall_isZero_ocall,
    (oe_ocall_func_t) ocall_and_ocall,
    (oe_ocall_func_t) ocall_or_ocall,
    (oe_ocall_func_t) ocall_xor_ocall,
    (oe_ocall_func_t) ocall_not_ocall,
    (oe_ocall_func_t) ocall_byte_ocall,
    (oe_ocall_func_t) ocall_shl_ocall,
    (oe_ocall_func_t) ocall_shr_ocall,
    (oe_ocall_func_t) ocall_mstore8_ocall,
    (oe_ocall_func_t) ocall_calldataload_ocall,
    (oe_ocall_func_t) ocall_blockhash_ocall,
    (oe_ocall_func_t) ocall_sha3_ocall,
    (oe_ocall_func_t) ocall_generate_address_ocall,
    (oe_ocall_func_t) ocall_to_big_endian_ocall,
    (oe_ocall_func_t) ocall_from_big_endian_ocall,
    (oe_ocall_func_t) ocall_oe_sgx_get_cpuid_table_ocall,
    NULL
};

oe_result_t oe_create_enclave_enclave(
    const char* path,
    oe_enclave_type_t type,
    uint32_t flags,
    const oe_enclave_setting_t* settings,
    uint32_t setting_count,
    oe_enclave_t** enclave)
{
    return oe_create_enclave(
               path,
               type,
               flags,
               settings,
               setting_count,
               __enclave_ocall_function_table,
               32,
               __enclave_ecall_info_table,
                2,
               enclave);
}

OE_EXTERNC_END
